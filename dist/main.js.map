{"version":3,"sources":["webpack:///./src/svgArray.js","webpack:///./src/index.js","webpack:///./src/convertSVG.js","webpack:///./src/physics.js","webpack:///./src/mousePhysics.js"],"names":["svgIdArray","document","getElementById","children","svg","push","id","canvas","context","getContext","backgroundCTX","width","height","style","background","imagesObject","convertedSVGS","map","svgId","Image","iterateTheObject","Object","keys","svgid","xml","XMLSerializer","serializeToString","btoa","convertSVG","src","gravity","mouse","x","undefined","y","addEventListener","event","Orb","xpos","ypos","radius","speed","image","this","dx","dy","beginPath","fillStyle","arc","Math","PI","fill","closePath","save","strokeStyle","lineWidth","clip","drawImage","stroke","restore","xBound","yBound","draw","orbCollection","randomNumber","min","max","random","i","length","randomx","randomy","animate","clearRect","forEach","ballA","update","ballB","collision","rSum","sqrt","checkCollision","depth","correction","normal","magnitude","adjustPositions","relVelocity","velocityOnNormal","j","impulse","resolveCollision","mouseCollision","checkMouseCollision","adjustPositionAfterMouse","resolveMouseCollision","console","log","requestAnimationFrame"],"mappings":"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","file":"main.js","sourcesContent":["export const svgArray = {\r\n    //need to fill\r\n};\r\n\r\nconst svgDiv = document.getElementById(\"svgs\").children;\r\nexport const svgIdArray = [];\r\n\r\nfor (let svg of svgDiv) {\r\n        \r\n     svgIdArray.push(svg.id);\r\n        \r\n};\r\n\r\n\r\n","import './styles/index.css';\r\n\r\nimport { svgIdArray } from './svgArray';\r\nimport { convertSVG } from './convertSVG';\r\nimport { checkCollision, resolveCollision, adjustPositions } from './physics';\r\nimport { checkMouseCollision, resolveMouseCollision, adjustPositionAfterMouse } from './mousePhysics';\r\n\r\n\r\nconst canvas = document.getElementById(\"canvas\");\r\nconst context = canvas.getContext(\"2d\");\r\nconst backgroundCTX = canvas.getContext(\"2d\");\r\n\r\ncanvas.width = 400;\r\ncanvas.height = 800;\r\n\r\ncanvas.style.background = \"#232a2e\"\r\n\r\n//LETS MAKE THE OBJECT TO HOLD THE IMAGES WITH KEYS\r\nconst imagesObject = {};\r\nconst convertedSVGS = {}\r\n//the key has to be called with bracket notation here \r\n//with dot notation assignment we get one key, svgId\r\n\r\nsvgIdArray.map(svgId => imagesObject[svgId] = new Image()); \r\n\r\nconst iterateTheObject = Object.keys(imagesObject);\r\n\r\niterateTheObject.map(svgId => convertedSVGS[svgId] = convertSVG(svgId));\r\n\r\n//this correctly assigns the src\r\nfor (let svgId of iterateTheObject) {\r\n    imagesObject[svgId].src = convertedSVGS[svgId];\r\n};\r\n\r\nconst gravity = [0, -0.05];\r\n\r\n/*///////////////TODO////////////////\r\n\r\n//- Add impulse to other balls on mouse click-\r\n//   --we can change their dx and dy based on ~*~triangles\r\n\r\n//- Figure out how to incorporate the canvas into react\r\n\r\n///////////////////////////////////*/\r\n\r\n//Lets make a mouse object and a mousemove event listener to track it\r\nconst mouse = {\r\n    x: undefined,\r\n    y: undefined,\r\n};\r\n\r\ncanvas.addEventListener(\"mousemove\", (event) => {\r\n    mouse.x = event.x;\r\n    mouse.y = event.y;\r\n})\r\n\r\n\r\n\r\n\r\n/////////////////////////////////////////////////////\r\n\r\nclass Orb {\r\n    constructor(xpos, ypos, radius, speed, image) {\r\n        this.xpos = xpos;\r\n        this.ypos = ypos;\r\n        this.radius = radius;\r\n        this.speed = speed;\r\n        this.image = image;\r\n        //set deltas\r\n        this.dx = 1.5 * this.speed;\r\n        this.dy = 1 * this.speed;\r\n    }\r\n    draw(context, backgroundCTX) {\r\n        backgroundCTX.beginPath();\r\n        backgroundCTX.fillStyle = \"white\";\r\n        backgroundCTX.arc(this.xpos, this.ypos, this.radius, 0, Math.PI * 2, false);\r\n        backgroundCTX.fill();\r\n        backgroundCTX.closePath();\r\n\r\n        context.save();\r\n        context.beginPath();\r\n        /*test*/context.strokeStyle = \"white\";\r\n        /*test*/context.lineWidth = 5;\r\n        context.arc(this.xpos, this.ypos, this.radius, 0, Math.PI * 2, false);\r\n        context.clip();\r\n        context.drawImage(this.image, (this.xpos - this.radius), (this.ypos - this.radius), 64, 64);\r\n        /*test*/context.stroke();\r\n        context.restore();\r\n    }\r\n    update() {\r\n        const xBound = canvas.width;\r\n        const yBound = canvas.height;\r\n\r\n        this.xpos += this.dx;\r\n        this.ypos += this.dy;\r\n\r\n        this.dx += gravity[0];\r\n        this.dy -= gravity[1];\r\n\r\n        if (this.xpos > xBound - this.radius) {\r\n            this.xpos = xBound - this.radius;\r\n            this.dx *= -1;\r\n        }\r\n\r\n        else if (this.xpos < this.radius) {\r\n            this.xpos = this.radius;\r\n            this.dx *= -1;\r\n        }\r\n\r\n        if (this.ypos > yBound - this.radius) {\r\n            this.ypos = yBound - this.radius;\r\n            this.dy *= -0.7;\r\n        }\r\n\r\n        else if (this.ypos < this.radius) {\r\n            this.ypos = this.radius + 1\r\n            this.dy *= -0.7;\r\n        }\r\n\r\n        \r\n\r\n        this.draw(context, backgroundCTX);\r\n    }\r\n            \r\n}\r\nconst orbCollection = [];\r\n\r\n//for not spawning balls inside the walls\r\nconst randomNumber = (min, max) => {\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\nfor (let i = 0; i < svgIdArray.length; i++) {\r\n    let randomx = randomNumber(32, (canvas.width - 32));\r\n    let randomy = randomNumber(32, (canvas.height - 32));\r\n    orbCollection.push(new Orb(randomx, randomy, 32, 1, imagesObject[svgIdArray[i]]));\r\n    \r\n}\r\n\r\nconst animate = () => {\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    orbCollection.forEach(ballA => {\r\n        ballA.update();\r\n\r\n        orbCollection.forEach(ballB => {\r\n            if (ballA !== ballB) {\r\n                const collision = checkCollision(ballA, ballB);\r\n                if (collision[0]) {\r\n                    adjustPositions(ballA, ballB, collision[1]);\r\n                    resolveCollision(ballA, ballB);\r\n                }\r\n            }\r\n        });\r\n\r\n        //new stuff for mouse collisions\r\n        const mouseCollision = checkMouseCollision(ballA, mouse);\r\n        \r\n        if (mouseCollision[0] && mouseCollision[1]) {\r\n            \r\n            adjustPositionAfterMouse(ballA, mouse, mouseCollision[1]);\r\n            resolveMouseCollision(ballA, mouse);\r\n            console.log(mouse, ballA);\r\n        }\r\n    });\r\n    requestAnimationFrame(animate);\r\n}\r\n\r\nanimate();\r\n\r\n\r\n\r\n\r\n\r\n//old animate function\r\n\r\n// const animateFunction = () => {\r\n//     requestAnimationFrame(animateFunction);\r\n//     //clear whole canvas every frame\r\n//     context.clearRect(0, 0, canvas.width, canvas.height);\r\n//     orbCollection.forEach(orb => {\r\n//         orb.update();\r\n//     });\r\n// }\r\n\r\n// //removed this being inside the window.onload callback function\r\n// //should leave a not here just in case\r\n// //this used to be window.onload = () => {animateFunction();}\r\n//     animateFunction();\r\n\r\n\r\n//test//////////////////////////\r\n// console.log(svgIdArray); this works\r\n////////////////////////////////\r\n","export const convertSVG = (svgid) => {\r\n    const svg = document.getElementById(svgid);\r\n\r\n    const xml = new XMLSerializer().serializeToString(svg);\r\n\r\n    const svg64 = btoa(xml);\r\n    const b64Start = 'data:image/svg+xml;base64, ';\r\n\r\n    return b64Start + svg64;\r\n}","export const checkCollision = (ballA, ballB) => {\r\n    const rSum = ballA.radius + ballB.radius;\r\n    const dx = ballB.xpos - ballA.xpos;\r\n    const dy = ballB.ypos - ballA.ypos;\r\n\r\n    return [(rSum * rSum) > (dx * dx) + (dy * dy), rSum - Math.sqrt((dx * dx) + (dy * dy))];\r\n}\r\n//making vector representations here\r\n\r\nexport const resolveCollision = (ballA, ballB) => {\r\n    const relVelocity = [(ballB.dx - ballA.dx), (ballB.dy - ballA.dy)];\r\n    let normal = [(ballB.xpos - ballA.xpos), (ballB.ypos - ballA.ypos)];\r\n    const magnitude = Math.sqrt((normal[0] * normal[0] + normal[1] * normal[1]));\r\n\r\n    //a bit confused why we rewrite the normal here\r\n    normal = [(normal[0] / magnitude), (normal[1] / magnitude)];\r\n\r\n    const velocityOnNormal = (relVelocity[0] * normal[0]) + (relVelocity[1] * normal[1]);\r\n\r\n    if (velocityOnNormal > 0) return;\r\n\r\n    const bounce = 0.7;\r\n    let j = -1 * (1 + bounce) * velocityOnNormal;\r\n    j /= (1 / ballA.radius) + (1 / ballB.radius);\r\n\r\n    const impulse = [(j * normal[0]), (j * normal[1])];\r\n\r\n    ballA.dx -= (1 / ballA.radius) * impulse[0];\r\n    ballB.dx += (1 / ballB.radius) * impulse[0];\r\n\r\n    ballA.dy -= (1 / ballA.radius) * impulse[1];\r\n    ballB.dy += (1 / ballB.radius) * impulse[1];\r\n}\r\n\r\nexport const adjustPositions = (ballA, ballB, depth) => {\r\n    const percent = 0.2;\r\n    const slope = 0.01;\r\n\r\n    let correction = (Math.max(depth - slope, 0) / (1 / ballA.radius) + (1 / ballB.radius)) * percent;\r\n\r\n    let normal = [(ballB.xpos - ballA.xpos), (ballB.ypos - ballA.ypos)];\r\n    const magnitude = Math.sqrt((normal[0] * normal[0]) + (normal[1] * normal[1]));\r\n\r\n    normal = [(normal[0] / magnitude), (normal[1] / magnitude)];\r\n    correction = [(correction * normal[0]), (correction * normal[1])];\r\n\r\n    ballA.xpos -= (1 / ballA.radius) * correction[0];\r\n    ballB.xpos += (1 / ballB.radius) * correction[0];\r\n\r\n    ballA.ypos -= (1 / ballA.radius) * correction[1];\r\n    ballB.ypos += (1 / ballB.radius) * correction[1];\r\n\r\n}","export const checkMouseCollision = (ballA, mouse) => {\r\n    const rSum = ballA.radius;\r\n    const dx = mouse.x - ballA.xpos;\r\n    const dy = mouse.y - ballA.ypos;\r\n\r\n    return [(rSum * rSum) > (dx * dx) + (dy * dy), rSum - Math.sqrt((dx * dx) + (dy * dy))]\r\n}\r\n\r\nexport const resolveMouseCollision = (ballA, mouse) => {\r\n    const relVelocity = [(ballA.dx), (ballA.dy)];\r\n    let normal = [(mouse.x - ballA.xpos), (mouse.y - ballA.ypos)];\r\n    const magnitude = Math.sqrt((normal[0] * normal[0] + normal[1] * normal[1]));\r\n\r\n    normal = [(normal[0] / magnitude), (normal[1] / magnitude)];\r\n\r\n    const velocityOnNormal = (relVelocity[0] * normal[0]) + (relVelocity[1] * normal[1]);\r\n\r\n    if (velocityOnNormal > 0 ) return;\r\n\r\n    const bounce = 0.7;\r\n    let j = -1 * (1 + bounce) * velocityOnNormal;\r\n    j /= (1 / ballA.radius);\r\n\r\n    const impulse = [(j * normal[0]), (j * normal[1])];\r\n\r\n    ballA.dx -= ( 1 / ballA.radius ) * impulse[0];\r\n    ballA.dy -= ( 1 / ballA.radius ) * impulse[1];\r\n}\r\n\r\nexport const adjustPositionAfterMouse = (ballA, mouse, depth) => {\r\n    const percent = 0.2;\r\n    const slope = 0.01;\r\n\r\n    let correction = (Math.max(depth - slope, 0) / (1 / ballA.radius)) * percent;\r\n\r\n    let normal = [(mouse.x - ballA.xpos), (mouse.y - ballA.ypos)];\r\n    const magnitude = Math.sqrt((normal[0] * normal[0]) + (normal[1] * normal[1]));\r\n\r\n    normal = [(normal[0] / magnitude), (normal[1] / magnitude)];\r\n    correction = [(correction * normal[0]), (correction * normal[1])];\r\n\r\n    ballA.xpos -= ( 1 / ballA.radius ) * correction[0];\r\n    ballA.ypos -= ( 1 / ballA.radius ) * correction[1];\r\n}"],"sourceRoot":""}